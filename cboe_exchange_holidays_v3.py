# Adapted from code by Pierre Boutquin of Stack Overflow
# https://stackoverflow.com/questions/33094297/create-trading-holiday-calendar-with-pandas

import pandas as pd
import numpy as np
from pandas.tseries.holiday import \
    AbstractHolidayCalendar, Holiday, MO, nearest_workday, sunday_to_monday, \
    USMartinLutherKingJr, USPresidentsDay, GoodFriday, USMemorialDay, USLaborDay, USThanksgivingDay, \
    get_calendar

# Additional holidays
NewYearsDay = Holiday('New Year\'s Day', month=1, day=1, observance=sunday_to_monday)
USIndependenceDay = Holiday('Independence Day', month=7, day=4, observance=nearest_workday)
USColumbusDay = Holiday('Columbus Day', month=10, day=1, offset=pd.DateOffset(weekday=MO(2)))
USVeteransDay = Holiday('Veterans Day', month=11, day=11, observance=sunday_to_monday)
ChristmasDay = Holiday('Christmas', month=12, day=25, observance=nearest_workday)
NYSEUSMartinLutherKingJr = Holiday('Dr. Martin Luther King Jr.',
                                   start_date=pd.Timestamp(1998, 1, 1), month=1, day=1,
                                   offset=pd.DateOffset(weekday=MO(3)))     # Nationally 1986, but NYSE 1998
# Presidential Days of Mourning
GHWBushDayofMourning = Holiday('George H. W. Bush Day of Mourning', year=2018, month=12, day=5)
FordDayofMourning = Holiday('Gerald Ford Day of Mourning', year=2007, month=1, day=2)
ReaganDayofMourning = Holiday('Ronald Reagan Day of Mourning', year=2004, month=6, day=11)
NixonDayofMourning = Holiday('Richard Nixon Day of Mourning', year=1994, month=4, day=27)
# Disasters
HurricaneSandyMonday = Holiday('Hurricane Sandy', year=2012, month=10, day=29)
HurricaneSandyTuesday = Holiday('Hurricane Sandy', year=2012, month=10, day=30)
NineElevenTuesday = Holiday('9/11', year=2001, month=9, day=11)
NineElevenWednesday = Holiday('9/11', year=2001, month=9, day=12)
NineElevenThursday = Holiday('9/11', year=2001, month=9, day=13)
NineElevenFriday = Holiday('9/11', year=2001, month=9, day=14)

# AbstractHolidayCalendar's class attributes determine effective date range of holidays
AbstractHolidayCalendar.start_date = pd.Timestamp(1970, 1, 1)
AbstractHolidayCalendar.end_date = pd.Timestamp(2099, 12, 31)   # Default 2030-12-31 doesn't cover bond maturities


class BaseTradingCalendar(AbstractHolidayCalendar):
    """ Base calendar containing US holidays that are universally recognized
    """
    def __init__(self):
        AbstractHolidayCalendar.__init__(self)
        self.rules = [
            NewYearsDay,
            USMartinLutherKingJr,
            USPresidentsDay,
            GoodFriday,
            USMemorialDay,
            USIndependenceDay,
            USLaborDay,
            USThanksgivingDay,
            ChristmasDay
        ]


class CboeTradingCalendar(BaseTradingCalendar):
    """ Cboe's trading calendar; should be the same as NYSE, confirmed back to 1990
        NOTE: if Jan 1 is on a Saturday, New Year's Day is technically not "observed"
              (source: http://cfe.cboe.com/about-cfe/holiday-calendar),
              though it is still listed in the holidays list generated by this
              calendar; it should never matter though, as it's already a weekend
    """
    def __init__(self):
        BaseTradingCalendar.__init__(self)
        self.rules.extend([GHWBushDayofMourning, FordDayofMourning, ReaganDayofMourning, NixonDayofMourning,
                           HurricaneSandyMonday, HurricaneSandyTuesday,
                           NineElevenTuesday, NineElevenWednesday, NineElevenThursday, NineElevenFriday])
        # NYSE/Cboe began observing MLK Day in 1998, not 1986 when it became nationally recognized
        self.rules.remove(USMartinLutherKingJr)
        self.rules.extend([NYSEUSMartinLutherKingJr])


class FICCGSDBusinessCalendar(BaseTradingCalendar):
    """ FICC's GSD business calendar, i.e. days on which Treasury notes can be delivered
        NOTE: observes federal holidays (Columbus and Veterans Day) AND Good Friday
        NOTE: empirically, we see it observes Bush Sr. Day of Mourning but NOT Ford's
              DoM (2007-01-02) or Hurricane Sandy (2012-10-29 and 30); may be other exceptions
    """
    def __init__(self):
        BaseTradingCalendar.__init__(self)
        self.rules.extend([USColumbusDay, USVeteransDay, GHWBushDayofMourning])


def datelike_to_timestamp(datelike, strip=False):
    """ Utility: Convert date-like representations to pd.Timestamps, for consistency
        NOTE: if datelike must be converted, it is first changed to string to avoid becoming nanoseconds
    :param datelike: date-like representation, e.g. ['2019-01-03', '2020-02-25'], datetime object, etc.
    :param strip: set True to strip datelike of time and leave only date (.normalize())
    :return: pd.Timestamp version of dates
    """
    if isinstance(datelike, pd.Series) or isinstance(datelike, np.ndarray):
        # Optimized multi-element input
        if datelike.dtype == np.dtype('datetime64[ns]'):
            ts_or_ts_series = datelike
        else:
            ts_or_ts_series = pd.to_datetime(datelike.astype(str))
    elif isinstance(datelike, pd.Timestamp):
        # Optimized single-element input
        ts_or_ts_series = datelike
    elif isinstance(datelike, str):
        # Semi-optimized single-element input
        ts_or_ts_series = pd.to_datetime(datelike)
    else:
        try:
            # Generic multi-element (iterable) input
            ts_or_ts_series = pd.to_datetime(list(map(str, datelike)))
        except TypeError:
            # Generic single-element input
            ts_or_ts_series = pd.to_datetime(str(datelike))
    return ts_or_ts_series if not strip else strip_to_date(ts_or_ts_series)


def timelike_to_timedelta(timelike):
    """ Utility: Convert time-like representations to pd.Timedeltas, for consistency
    :param timelike: time-like representation, e.g. ['16:15:43', '10:28:43'], datetime object, etc.
    :return: pd.Timedelta version of times
    """
    if isinstance(timelike, pd.Series) or isinstance(timelike, np.ndarray):
        # Optimized multi-element input
        if timelike.dtype == np.dtype('timedelta64[ns]'):
            return timelike
        else:
            return pd.to_timedelta(timelike)
    elif isinstance(timelike, pd.Timedelta):
        # Optimized single-element input
        return timelike
    else:
        # Generic input
        return pd.to_timedelta(timelike)


def strip_to_date(timestamp):
    """ Utility: Strip pd.Timestamps to dates only
    :param timestamp: pd.Timestamp(s) to strip
    :return: pd.Timestamp version of dates with no spare hours, minutes, seconds, or fractions of second
    """
    if isinstance(timestamp, pd.Series):
        # Optimized multi-element input
        return timestamp.dt.normalize()     # .replace(hour=0, minute=0, second=0, microsecond=0)
    elif isinstance(timestamp, np.ndarray):
        # Semi-optimized multi-element input
        return pd.Series(timestamp).dt.normalize()
    else:
        # Single-element input
        return timestamp.normalize()


def _get_holidays_start_end(cal, start_datelike, end_datelike=None, fancy=False):
    """ Helper: Return list of holidays given start and (optionally) end date
    :param cal: calendar object that has holidays() method
    :param start_datelike: start date, as a date-like representation
    :param end_datelike: end date, as a date-like representation; default current date
    :param fancy: set True to get visually fancy output
    :return: collection of holidays
    """
    start_date = datelike_to_timestamp(start_datelike)
    if end_datelike is None:
        end_date = pd.Timestamp('now').strftime('%Y-%m-%d')     # Today
    else:
        end_date = datelike_to_timestamp(end_datelike)
    return cal.holidays(start_date, end_date, fancy)


def _get_holidays_year(cal, year, fancy=False):
    """ Helper: Return list of holidays in the given year
    :param cal: calendar object that has holidays() method
    :param year: year from which to get holidays
    :param fancy: set True to get visually fancy output
    :return: collection of holidays
    """
    start_date = pd.Timestamp(year, 1, 1)
    end_date = pd.Timestamp(year, 12, 31)
    return cal.holidays(start_date, end_date, fancy)


def get_cboe_holidays(year=None, start_datelike=None, end_datelike=None, fancy=False):
    """ Return list of Cboe exchange holidays
        NOTE: every parameter defaults to None in order to allow 3 configurations:
              1) only year
              2) only start date
              3) start date and end date
    :param year: year from which to get holidays
    :param start_datelike: start date, as a date-like representation
    :param end_datelike: end date, as a date-like representation; default current date
    :param fancy: set True to get visually fancy output
    :return: collection of holidays
    """
    cboe_cal = get_calendar('CboeTradingCalendar')
    if year is not None:
        return _get_holidays_year(cboe_cal, year, fancy)
    else:
        return _get_holidays_start_end(cboe_cal, start_datelike, end_datelike, fancy)


def get_ficcgsd_holidays(year=None, start_datelike=None, end_datelike=None, fancy=False):
    """ Return list of FICC's GSD business holidays
        NOTE: every parameter defaults to None in order to allow 3 configurations:
              1) only year
              2) only start date
              3) start date and end date
    :param year: year from which to get holidays
    :param start_datelike: start date, as a date-like representation
    :param end_datelike: end date, as a date-like representation; default current date
    :param fancy: set True to get visually fancy output
    :return: collection of holidays
    """
    ficcgsd_cal = get_calendar('FICCGSDBusinessCalendar')
    if year is not None:
        return _get_holidays_year(ficcgsd_cal, year, fancy)
    else:
        return _get_holidays_start_end(ficcgsd_cal, start_datelike, end_datelike, fancy)


###############################################################################

if __name__ == '__main__':
    print("\nCboe Year Holidays Test\n")
    print("2011:\n{}".format(get_cboe_holidays(2011)))
    print("2016:\n{}".format(get_cboe_holidays(2016)))
    print("2019:\n{}".format(get_cboe_holidays(2019)))
    print("2022:\n{}".format(get_cboe_holidays(2022)))

    print("\nCboe Date Range Holidays Test\n")
    print("get_cboe_holidays(start_datelike='2019-11-08', end_datelike='2019-12-31'):\n{}"
          .format(get_cboe_holidays(start_datelike='2019-11-08', end_datelike='2019-12-31')))
    print("get_cboe_holidays(start_datelike=2018):\n{}"
          .format(get_cboe_holidays(start_datelike=2018)))

    print("\nTimestamp Utilities Test\n")
    print("**datelike_to_timestamp()**")
    single_element_gen_1 = '2020-02-25'
    single_element_gen_2 = 2020
    single_element_ts = pd.Timestamp('2020-02-25 11:31:08.542488')
    multi_element_gen = [single_element_ts, '2010-03-31', single_element_ts]
    multi_element_ser_gen = pd.Series(multi_element_gen)
    multi_element_ser_ts = pd.Series([single_element_ts] * 5)
    multi_element_arr_gen = np.array(multi_element_gen)
    multi_element_arr_ts = np.array([single_element_ts] * 5)
    datelike_test_list = [single_element_gen_1, single_element_gen_2, single_element_ts,
                          multi_element_gen, multi_element_ser_gen, multi_element_ser_ts,
                          multi_element_arr_gen, multi_element_arr_ts]
    for i, datelike_test in enumerate(datelike_test_list, 1):
        print(f"Test {i}:\n{datelike_to_timestamp(datelike_test)}")
    print("**timelike_to_timedelta()**")
    single_element_time_gen = '10:28:43'
    single_element_time_td = pd.Timedelta('10:28:43')
    multi_element_time_gen = ['16:15:43', '10:28:43', '10:28:43']
    multi_element_time_td = pd.to_timedelta(multi_element_time_gen)
    timelike_test_list = [single_element_time_gen, single_element_time_td,
                          multi_element_time_gen, multi_element_time_td]
    for i, timelike_test in enumerate(timelike_test_list, 1):
        print(f"Test {i}:\n{timelike_to_timedelta(timelike_test)}")
    print("**strip_to_date()**")
    print(f"strip_to_date(multi_element_ser_ts):\n{strip_to_date(multi_element_ser_ts)}")
    print(f"strip_to_date(multi_element_arr_ts):\n{strip_to_date(multi_element_arr_ts)}")

""" Expected Output
Cboe Year Holidays Test

2011:
DatetimeIndex(['2011-01-01', '2011-01-17', '2011-02-21', '2011-04-22',
               '2011-05-30', '2011-07-04', '2011-09-05', '2011-11-24',
               '2011-12-26'],
              dtype='datetime64[ns]', freq=None)
2016:
DatetimeIndex(['2016-01-01', '2016-01-18', '2016-02-15', '2016-03-25',
               '2016-05-30', '2016-07-04', '2016-09-05', '2016-11-24',
               '2016-12-26'],
              dtype='datetime64[ns]', freq=None)
2019:
DatetimeIndex(['2019-01-01', '2019-01-21', '2019-02-18', '2019-04-19',
               '2019-05-27', '2019-07-04', '2019-09-02', '2019-11-28',
               '2019-12-25'],
              dtype='datetime64[ns]', freq=None)
2022:
DatetimeIndex(['2022-01-01', '2022-01-17', '2022-02-21', '2022-04-15',
               '2022-05-30', '2022-07-04', '2022-09-05', '2022-11-24',
               '2022-12-26'],
              dtype='datetime64[ns]', freq=None)

Cboe Date Range Holidays Test

get_cboe_holidays(start_datelike='2019-11-08', end_datelike='2019-12-31'):
DatetimeIndex(['2019-11-28', '2019-12-25'], dtype='datetime64[ns]', freq=None)
get_cboe_holidays(start_datelike=2018):
DatetimeIndex(['2018-01-01', '2018-01-15', '2018-02-19', '2018-03-30',
               '2018-05-28', '2018-07-04', '2018-09-03', '2018-11-22',
               '2018-12-05', '2018-12-25', '2019-01-01', '2019-01-21',
               '2019-02-18', '2019-04-19', '2019-05-27', '2019-07-04',
               '2019-09-02'],
              dtype='datetime64[ns]', freq=None)

Timestamp Utilities Test

**datelike_to_timestamp()**
Test 1:
2020-02-25 00:00:00
Test 2:
2020-01-01 00:00:00
Test 3:
2020-02-25 11:31:08.542488
Test 4:
DatetimeIndex(['2020-02-25 11:31:08.542488',        '2010-03-31 00:00:00',
               '2020-02-25 11:31:08.542488'],
              dtype='datetime64[ns]', freq=None)
Test 5:
0   2020-02-25 11:31:08.542488
1   2010-03-31 00:00:00.000000
2   2020-02-25 11:31:08.542488
dtype: datetime64[ns]
Test 6:
0   2020-02-25 11:31:08.542488
1   2020-02-25 11:31:08.542488
2   2020-02-25 11:31:08.542488
3   2020-02-25 11:31:08.542488
4   2020-02-25 11:31:08.542488
dtype: datetime64[ns]
Test 7:
DatetimeIndex(['2020-02-25 11:31:08.542488',        '2010-03-31 00:00:00',
               '2020-02-25 11:31:08.542488'],
              dtype='datetime64[ns]', freq=None)
Test 8:
DatetimeIndex(['2020-02-25 11:31:08.542488', '2020-02-25 11:31:08.542488',
               '2020-02-25 11:31:08.542488', '2020-02-25 11:31:08.542488',
               '2020-02-25 11:31:08.542488'],
              dtype='datetime64[ns]', freq=None)
**timelike_to_timedelta()**
Test 1:
0 days 10:28:43
Test 2:
0 days 10:28:43
Test 3:
TimedeltaIndex(['16:15:43', '10:28:43', '10:28:43'], dtype='timedelta64[ns]', freq=None)
Test 4:
TimedeltaIndex(['16:15:43', '10:28:43', '10:28:43'], dtype='timedelta64[ns]', freq=None)
**strip_to_date()**
strip_to_date(multi_element_ser_ts):
0   2020-02-25
1   2020-02-25
2   2020-02-25
3   2020-02-25
4   2020-02-25
dtype: datetime64[ns]
strip_to_date(multi_element_arr_ts):
0   2020-02-25
1   2020-02-25
2   2020-02-25
3   2020-02-25
4   2020-02-25
dtype: datetime64[ns]
"""
